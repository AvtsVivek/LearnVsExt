// Copyright © 2018 Transeric Solutions.  All rights reserved.
// Author: Eric David Lynch
// License: https://www.codeproject.com/info/cpol10.aspx
using System;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Language.Intellisense;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.TextManager.Interop;

namespace ColorfulEditor
{
	/// <summary>
	/// A target for an Object Linking and Embedding (OLE) command.
	/// </summary>
	/// <remarks>
	/// Adapted from https://docs.microsoft.com/en-us/visualstudio/extensibility/walkthrough-displaying-statement-completion.
	/// </remarks>
	internal sealed class ColorfulOleCommandTarget : IOleCommandTarget
	{
		#region Constructors
		/// <summary>
		/// Create an instance for with the specified text view components.
		/// </summary>
		/// <param name="vsTextView">The Visual Studio text view for this OLE command target.</param>
		/// <param name="textView">The WPF text view for this OLE command target.</param>
		/// <param name="completionBroker">The central broker responsible for IntelliSense completion.</param>
		/// <param name="serviceProvider">The central Visual Studio service provider.</param>
		internal ColorfulOleCommandTarget(IVsTextView vsTextView, ITextView textView,
			ICompletionBroker completionBroker, SVsServiceProvider serviceProvider)
		{
			CompletionBroker = completionBroker;
			ServiceProvider = serviceProvider;
			TextView = textView;

			// Add ourself to the chain of command targets for the specified text view adapter
			vsTextView.AddCommandFilter(this, out nextCommandTarget);
		}
		#endregion // Constructors

		#region Private data
		private ICompletionSession completionSession;
		private IOleCommandTarget nextCommandTarget;
		#endregion // Private data

		#region Properties
		/// <summary>
		/// Gets the central broker responsible for IntelliSense completion.
		/// </summary>
		internal ICompletionBroker CompletionBroker { get; }

		/// <summary>
		/// Gets the central Visual Studio service provider.
		/// </summary>
		internal SVsServiceProvider ServiceProvider { get; }

		/// <summary>
		/// Gets the WPF text view for this OLE command target.
		/// </summary>
		internal ITextView TextView { get; }
		#endregion // Properties

		#region Public methods
		/// <summary>
		/// Executes the specified command or displays help for the command.
		/// </summary>
		/// <param name="pguidCmdGroup">The globally unique identifier of the command group; can be <see langword="null" /> to specify the standard group.</param>
		/// <param name="nCmdID">The identity of the command to execute.</param>
		/// <param name="nCmdexecopt">Specifies how the object should execute the command.</param>
		/// <param name="pvaIn">A pointer to a structure containing input arguments (or <see langword="null"/>).</param>
		/// <param name="pvaOut">A pointer to a structure to receive command output (or <see langword="null"/>).</param>
		/// <returns>This method returns <see cref="VSConstants.S_OK"/> on success; otherwise, something else.</returns>
		public int Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt,
			IntPtr pvaIn, IntPtr pvaOut)
		{
			// If we are in an automation function (e.g. test automation), just pass along
			// the command to the next command target in the chain
			if (VsShellUtilities.IsInAutomationFunction(ServiceProvider))
				return nextCommandTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);

			// Get the character that was typed (if any)
			char? typedChar = GetTypedChar(pguidCmdGroup, nCmdID, pvaIn);

			// If the user committed a selection, finish the session and return
			if (HandleCommit(nCmdID, typedChar))
				return VSConstants.S_OK;

			// Pass along the command to the next command target in the chain, so that
			// any typed character is added to the buffer
			int result = nextCommandTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt,
				pvaIn, pvaOut);

			// On success, handle IntelliSense completion for the typed character / command
			return ErrorHandler.Succeeded(result) ?
				HandleCompletion(nCmdID, typedChar, result) : result;
		}

		/// <summary>
		/// Query the status of one or more commands generated by user interface events.
		/// </summary>
		/// <param name="pguidCmdGroup">The globally unique identifier of the command group; can be <see langword="null" /> to specify the standard group.</param>
		/// <param name="cCmds">The number of commands in the <paramref name="prgCmds"/> array.</param>
		/// <param name="prgCmds">A caller-allocated array of <see cref="OLECMD"/> structures that indicate the commands for which the caller needs status information.  This method sets the <see cref="OLECMD.cmdf"/> field.</param>
		/// <param name="pCmdText"></param>
		/// <returns>This method returns <see cref="VSConstants.S_OK"/> on success; otherwise, something else.</returns>
		/// <remarks>
		/// We simply allow the next command target in the chain to report the status.
		/// </remarks>
		public int QueryStatus(ref Guid pguidCmdGroup, uint cCmds,
			OLECMD[] prgCmds, IntPtr pCmdText) =>
			nextCommandTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
		#endregion // Public methods

		#region Private methods
		// Get the character the user typed (if any)
		private char? GetTypedChar(Guid commandGroup, uint commandId, IntPtr pvaIn) =>
			commandGroup == VSConstants.VSStd2K &&
			commandId == (uint)VSConstants.VSStd2KCmdID.TYPECHAR ?
			(char)(ushort)Marshal.GetObjectForNativeVariant(pvaIn) : (char?)null;

		// Test if there is an active IntelliSense completion session
		private bool HasCompletionSession() =>
			completionSession != null && !completionSession.IsDismissed;

		// Test if the command requests a selection to be committed
		private bool IsCommitCommand(uint commandId) =>
			commandId == (uint)VSConstants.VSStd2KCmdID.RETURN ||
			commandId == (uint)VSConstants.VSStd2KCmdID.TAB;

		// Test if the typed character requests a selection to be committed
		private bool IsCommitChar(char? typedChar) =>
			typedChar.HasValue && (Char.IsWhiteSpace(typedChar.Value) ||
				Char.IsPunctuation(typedChar.Value));

		// Test that the specified ITextBuffer is not a projection location
		private bool IsNotProjection(ITextBuffer textBuffer) =>
			!textBuffer.ContentType.IsOfType("projection");

		// If the user initiated a commit, either dismiss or commit the session
		private bool HandleCommit(uint commandId, char? typedChar)
		{
			if (!HasCompletionSession() || (!IsCommitCommand(commandId) && !IsCommitChar(typedChar)))
				return false;

			if (!completionSession.SelectedCompletionSet.SelectionStatus.IsSelected)
			{
				completionSession.Dismiss();
				return false;
			}

			completionSession.Commit();
			return true;
		}

		// Handle IntelliSense completion for the typed character / command.
		// Return either the result from the next command or "OK" (if we performed filtering).
		private int HandleCompletion(uint commandId, char? typedChar, int result)
		{
			if (typedChar.HasValue && Char.IsLetterOrDigit(typedChar.Value))
			{
				if (!TriggerCompletion())
					return result;
			}
			else
				if ((commandId != (uint)VSConstants.VSStd2KCmdID.BACKSPACE &&
					 commandId != (uint)VSConstants.VSStd2KCmdID.DELETE) ||
					!HasCompletionSession())
					return result;

			completionSession.Filter();
			return VSConstants.S_OK;
		}

		// Unsubscribe and forget the completion session when it is dismissed
		private void OnSessionDismissed(object sender, EventArgs e)
		{
			completionSession.Dismissed -= OnSessionDismissed;
			completionSession = null;
		}

		// Create an IntelliSense completion session for the word at the
		// current caret (cursor) position
		private bool TriggerCompletion()
		{
			// If completion is already active, simply return
			if (HasCompletionSession())
				return true;

			// Get a non-projection location for the caret (cursor)
			SnapshotPoint? caretPoint = TextView.Caret.Position.Point.GetPoint(
				IsNotProjection, PositionAffinity.Predecessor);
			if (!caretPoint.HasValue)
				return false;

			// Create a tracking point for that position
			ITrackingPoint trackingPoint = caretPoint.Value.Snapshot.CreateTrackingPoint(
				caretPoint.Value.Position, PointTrackingMode.Positive);

			// Create a completion session for the word at that position
			completionSession = CompletionBroker.CreateCompletionSession(
				TextView, trackingPoint, true);

			// Subscribe to the dismissed event.  This way when the session ends we know
			// to create a new one the next time IntelliSense completion is triggered
			completionSession.Dismissed += OnSessionDismissed;

			// Start the IntelliSense completion session
			completionSession.Start();

			// Indicate that we successfully triggered an IntelliSense completion session
			return true;
		}
		#endregion // Private methods
	}
}
